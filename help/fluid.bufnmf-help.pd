#N canvas 36 25 692 887 12;
#X obj 458 670 cnv 15 215 196 empty empty More\ information 4 10 0 13 #e0e0e0 #404040 0;
#N canvas 299 199 689 856 fixed_bases 0;
#X obj 15 13 cnv 15 660 42 empty empty fluid.bufnmf 1 22 0 36 #4ba3fb #ffffff 0;
#X text 13 70 using the basesmode or actmode attributes \, we can guide NMF's behaviour to 'find' particular spectral components, f 92;
#X obj 15 139 bng 15 250 50 0 empty empty empty 17 7 0 10 #c6ffc7 #000000 #000000;
#X obj 459 498 array define help.nmf.src.4;
#X f 29;
#X obj 19 802 fluid.out~ bufnmfhelp;
#X obj 87 807 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X text 88 806 2) turn sound on;
#X obj 459 556 clone fluid.multiarray 10 help.nmf.resynth.4, f 29;
#X obj 35 139 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X text 36 138 1);
#X text 56 138 start analysis;
#N canvas 1162 -1080 827 819 find_media_spectral_centroids 0;
#X obj 37 127 inlet;
#X text 34 11 This subpatch analyses each resynthesised component for the median spectral centroid., f 77;
#X text 34 51 It uses automatic buffer management to minimise the number of temporary buffers we have to use as well as leverages -select to pick out the descriptors we want instead of having to parse through a multi-channel buffer ourselves., f 80;
#X msg 37 151 buffer help.nmf.resynth.4;
#X obj 37 245 fluid.bufspectralshape -select centroid;
#X obj 37 379 fluid.bufstats -select mid;
#X obj 37 671 outlet;
#X msg 37 567 0;
#X obj 37 595 array get;
#X msg 97 533 symbol \$1;
#X listbox 78 642 98 0 0 0 - - - 0;
#X obj 97 561 makefilename %s-0;
#X obj 37 452 fluid.bufflatten;
#X obj 37 491 t b a;
#X text 226 146 10 channel buffer in. Each channel is a resynthesised component.;
#X text 228 182 When we pass this message to bufspectralshape~ it processes this as the input.;
#X text 322 240 Process each channel of the resynthesised output. Only retrieve the centroid giving us a new 10 channel buffer.;
#X listbox 57 315 30 0 0 0 - - - 0;
#X obj 57 292 list;
#X text 278 310 No output buffer is set for fluid.bufspectralshape~ so it uses an internal one and provides the name for us.;
#X text 232 373 This is ergonomically similar to spectralshape. We receive a buffer to process and haven't set an output so everything operates on buffers internal to each object., f 56;
#X text 163 448 Flatten the 10 channel size 1 buffer into a single channel 10 element array;
#X connect 0 0 3 0;
#X connect 3 0 4 0;
#X connect 4 0 5 0;
#X connect 4 0 18 0;
#X connect 5 0 12 0;
#X connect 7 0 8 0;
#X connect 8 0 10 0;
#X connect 8 0 6 0;
#X connect 9 0 11 0;
#X connect 11 0 8 2;
#X connect 12 0 13 0;
#X connect 13 0 7 0;
#X connect 13 1 9 0;
#X connect 18 0 17 0;
#X restore 15 211 pd find_media_spectral_centroids;
#X obj 459 629 clone fluid.multiarray 2 help.nmf.pickstringseparation, f 29;
#N canvas 0 22 450 278 (subpatch) 0;
#X array help.bufnmf.fixed.display 10 float 3;
#A 0 476.217 780.346 3335.66 419.201 1037.91 4727.09 2275.09 542.004 5721.27 8781.46;
#X coords 0 20000 10 0 167 78 1 0 0;
#X restore 265 288 graph;
#N canvas 1720 -660 377 166 display 0;
#X obj 37 37 inlet;
#X obj 37 67 list;
#X obj 37 92 array set help.bufnmf.fixed.display;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X restore 264 251 pd display;
#N canvas 1394 -1050 595 343 find_index_of_highest_centroid 0;
#X obj 37 28 inlet;
#X listbox 106 193 20 0 0 0 - - - 0;
#X listbox 265 193 42 0 0 0 - - - 0;
#X listbox 130 102 46 0 0 0 - - - 0;
#X obj 37 69 t b a, f 9;
#X obj 37 254 outlet;
#X obj 97 254 outlet;
#X obj 255 254 outlet;
#N canvas 69 -1042 1390 871 splitlist 0;
#N canvas 1888 -777 554 463 iteratelist 0;
#X obj 70 45 inlet;
#X obj 36 109 until;
#X text 135 78 First store list \, then start the loop;
#X text 130 128 "until" bangs its output until told to stop by a "bang" to its right inlet., f 38;
#X text 140 192 Store the remaining list.;
#X obj 49 192 list store;
#X obj 70 76 t b b l;
#X obj 36 134 f;
#X obj 74 135 + 1;
#X msg 93 109 0, f 2;
#X msg 36 165 get \$1 1;
#X text 296 25 copied from PD help;
#X obj 49 226 outlet;
#X connect 0 0 6 0;
#X connect 1 0 7 0;
#X connect 5 0 12 0;
#X connect 5 1 1 1;
#X connect 6 0 1 0;
#X connect 6 1 9 0;
#X connect 6 2 5 1;
#X connect 7 0 8 0;
#X connect 7 0 10 0;
#X connect 8 0 7 1;
#X connect 9 0 7 1;
#X connect 10 0 5 0;
#X restore 201 104 pd iteratelist;
#X obj 317 104 list length, f 9;
#X floatatom 317 143 5 0 0 0 - - - 0;
#X obj 203 301 pack 0 0;
#X msg 432 176 0;
#X obj 256 260 f, f 8;
#X obj 364 246 + 1;
#X obj 409 245 sel 0;
#X obj 364 272 mod 10;
#X obj 256 216 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000;
#X obj 201 136 t f b, f 8;
#X obj 547 572 text define ordinal-\$0;
#X f 10;
#X obj 250 431 text insert ordinal-\$0;
#X msg 325 400 0;
#X msg 203 331 \$1 \$2;
#X msg 547 128 clear;
#X obj 203 367 t b a b, f 14;
#X msg 203 474 sort;
#X obj 88 675 f, f 8;
#X obj 196 666 + 1;
#X obj 241 665 sel 0;
#X obj 196 692 mod 10;
#X obj 88 635 until;
#X floatatom 88 710 5 0 0 0 - - - 0;
#X obj 88 739 expr 9-$f1;
#X obj 88 572 t f b, f 32;
#X obj 88 770 text get ordinal-\$0, f 21;
#X msg 88 796 \$2;
#X listbox 186 854 26 0 0 0 - - - 0;
#X obj 219 819 t a;
#X obj 88 820 list prepend;
#X listbox 138 904 20 0 0 0 - - - 0;
#X listbox 308 904 25 0 0 0 - - - 0;
#X obj 88 543 f, f 33;
#X obj 88 71 t b a a b b, f 66;
#X msg 308 693 symbol;
#X obj 88 856 list split 1;
#X obj 128 882 list split 1, f 46;
#X obj 128 932 outlet;
#X obj 287 932 outlet;
#X obj 88 15 inlet;
#X connect 0 0 10 0;
#X connect 1 0 2 0;
#X connect 2 0 8 1;
#X connect 2 0 33 1;
#X connect 3 0 14 0;
#X connect 4 0 5 1;
#X connect 5 0 6 0;
#X connect 5 0 3 1;
#X connect 6 0 8 0;
#X connect 8 0 5 1;
#X connect 8 0 7 0;
#X connect 9 0 5 0;
#X connect 10 0 3 0;
#X connect 10 1 9 0;
#X connect 13 0 12 1;
#X connect 14 0 16 0;
#X connect 15 0 11 0;
#X connect 16 0 17 0;
#X connect 16 1 12 0;
#X connect 16 2 13 0;
#X connect 17 0 11 0;
#X connect 18 0 19 0;
#X connect 18 0 23 0;
#X connect 19 0 21 0;
#X connect 20 0 22 1;
#X connect 21 0 18 1;
#X connect 21 0 20 0;
#X connect 22 0 18 0;
#X connect 23 0 24 0;
#X connect 24 0 26 0;
#X connect 25 0 22 0;
#X connect 25 1 35 0;
#X connect 26 0 27 0;
#X connect 27 0 30 0;
#X connect 29 0 30 1;
#X connect 30 0 28 0;
#X connect 30 0 29 0;
#X connect 30 0 36 0;
#X connect 33 0 25 0;
#X connect 34 0 33 0;
#X connect 34 1 0 0;
#X connect 34 2 1 0;
#X connect 34 3 4 0;
#X connect 34 4 15 0;
#X connect 35 0 30 1;
#X connect 36 1 37 0;
#X connect 37 0 31 0;
#X connect 37 0 38 0;
#X connect 37 1 32 0;
#X connect 37 1 39 0;
#X connect 40 0 34 0;
#X restore 97 169 pd splitlist;
#X f 23;
#X obj 97 133 list;
#X connect 0 0 4 0;
#X connect 4 0 5 0;
#X connect 4 1 3 0;
#X connect 4 1 9 0;
#X connect 8 0 1 0;
#X connect 8 0 6 0;
#X connect 8 1 2 0;
#X connect 8 1 7 0;
#X connect 9 0 8 0;
#X restore 15 251 pd find_index_of_highest_centroid;
#N canvas 2172 -848 310 179 loadsrc 0;
#X obj 16 101 soundfiler;
#X obj 16 27 loadbang;
#X msg 16 49 read -resize media/Tremblay-AaS-AcousticStrums-M.wav help.nmf.src.4, f 30;
#X connect 1 0 2 0;
#X connect 2 0 0 0;
#X restore 588 142 pd loadsrc;
#N canvas 1352 -989 630 534 make_new_bases 0;
#X obj 37 37 inlet;
#X obj 37 377 outlet;
#X obj 87 37 inlet;
#X obj 197 37 inlet;
#N canvas 1888 -777 554 463 iteratelist 0;
#X obj 70 45 inlet;
#X obj 36 109 until;
#X text 135 78 First store list \, then start the loop;
#X text 130 128 "until" bangs its output until told to stop by a "bang" to its right inlet., f 38;
#X text 140 192 Store the remaining list.;
#X obj 49 192 list store;
#X obj 70 76 t b b l;
#X obj 36 134 f;
#X obj 74 135 + 1;
#X msg 93 109 0, f 2;
#X msg 36 165 get \$1 1;
#X text 296 25 copied from PD help;
#X obj 49 226 outlet;
#X connect 0 0 6 0;
#X connect 1 0 7 0;
#X connect 5 0 12 0;
#X connect 5 1 1 1;
#X connect 6 0 1 0;
#X connect 6 1 9 0;
#X connect 6 2 5 1;
#X connect 7 0 8 0;
#X connect 7 0 10 0;
#X connect 8 0 7 1;
#X connect 9 0 7 1;
#X connect 10 0 5 0;
#X restore 197 108 pd iteratelist;
#X msg 87 258 deststartchan \$1 \, startchan \$2 \, bang;
#X msg 87 156 0 \$1;
#X obj 87 282 fluid.bufcompose -destgain 1 -numchans 1 -source help.nmf.bases.4 -destination help.nmf.summedbases, f 24;
#X msg 197 152 1 \$1;
#X connect 0 0 1 0;
#X connect 2 0 6 0;
#X connect 3 0 4 0;
#X connect 4 0 8 0;
#X connect 5 0 7 0;
#X connect 6 0 5 0;
#X connect 8 0 5 0;
#X restore 15 280 pd make_new_bases;
#X f 33;
#X obj 15 309 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000;
#X obj 19 567 bng 15 250 50 0 empty empty empty 17 7 0 10 #c6ffc7 #000000 #000000;
#X obj 39 567 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X obj 24 660 cnv 15 250 44 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X obj 149 736 *~;
#X obj 167 685 tgl 15 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 19 736 *~;
#X obj 37 685 tgl 15 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X text 26 661 select which components to hear:, f 33;
#N canvas 63 101 338 195 sum 0;
#X obj 54 39 inlet~;
#X obj 104 39 inlet~;
#X obj 54 72 +~;
#X obj 54 96 +~;
#X obj 54 120 outlet~;
#X connect 0 0 2 0;
#X connect 1 0 2 1;
#X connect 2 0 3 0;
#X connect 3 0 4 0;
#X restore 19 773 pd sum;
#X f 19;
#X text 53 683 pick;
#X text 184 682 resonance;
#X obj 15 432 fluid.bufnmf -source help.nmf.src.4 -bases help.nmf.summedbases -basesmode 2 -components 2 -resynth help.nmf.pickstringseparation -resynthmode 1 -blocking 0;
#X obj 15 496 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000;
#X obj 459 592 clone fluid.multiarray 2 help.nmf.summedbases, f 29;
#X text 40 566 3) start playback;
#X text 226 719 Because we used @basesmode 2 (fixed bases) \, the order of bases is no longer random but instead decided by the bases buffer we provide to the object., f 49;
#X text 226 799 This is how we can label channel 1 pick and channel 2 resonance beforehand., f 49;
#X obj 459 520 clone fluid.multiarray 10 help.nmf.bases.4, f 29;
#X obj 15 159 fluid.bufnmf -source help.nmf.src.4 -bases help.nmf.bases.4 -resynth help.nmf.resynth.4 -resynthmode 1 -components 10 -numframes 88200;
#X obj 19 604 tabplay~ help.nmf.pickstringseparation-0, f 18;
#X obj 159 604 tabplay~ help.nmf.pickstringseparation-1, f 17;
#N canvas 299 350 447 285 This_is_how_this_works 0;
#X text 16 18 How this works!;
#X text 16 48 1) Decompose 2 seconds of guitar in 10 components.;
#X text 16 78 2) Analyse the median spectral centroid of each resynthesised components.;
#X text 16 118 3) Find the component that has the highest median spectral centroid \, which we estimate to be the best guess of where the pick sound is.;
#X text 16 178 4) We then take the activation of that pick sound and place it in a buffer on channel 1 \, and sum all the others to channel 2 This 2 channel buffer becomes our new \, fixed template for a secondary fluid.bufnmf~ object that decomposes the whole file.;
#X restore 487 239 pd This_is_how_this_works;
#X connect 2 0 37 0;
#X connect 11 0 14 0;
#X connect 11 0 15 0;
#X connect 15 0 17 0;
#X connect 15 1 17 1;
#X connect 15 2 17 2;
#X connect 17 0 18 0;
#X connect 18 0 30 0;
#X connect 19 0 38 0;
#X connect 19 0 39 0;
#X connect 22 0 27 1;
#X connect 23 0 22 1;
#X connect 24 0 27 0;
#X connect 25 0 24 1;
#X connect 27 0 4 0;
#X connect 27 0 4 1;
#X connect 30 0 31 0;
#X connect 37 0 11 0;
#X connect 38 0 24 0;
#X connect 39 0 22 0;
#X restore 461 756 pd fixed_bases;
#N canvas 150 98 689 755 bases_and_activation1 0;
#X obj 17 13 cnv 15 660 42 empty empty fluid.bufnmf 1 22 0 36 #4ba3fb #ffffff 0;
#N canvas 1032 -1022 1154 936 visualisation 0;
#N canvas 0 23 450 278 (subpatch) 0;
#X array BasesLeft 513 float 0;
#X coords 0 1 512 0 250 70 1 0 0;
#X restore 105 150 graph;
#X obj 193 -193 array size;
#X obj 113 -169 array get;
#N canvas 0 23 450 278 (subpatch) 0;
#X array BasesRight 513 float 0;
#X coords 0 1 512 0 250 70 1 0 0;
#X restore 105 237 graph;
#X obj 193 -170 array size BasesLeft;
#X obj 113 -146 array set BasesLeft;
#X obj 113 -362 inlet;
#X obj 113 -254 t b b b, f 12;
#X msg 194 -228 symbol help.nmf.bases.2-0;
#N canvas 0 23 450 278 (subpatch) 0;
#X array ActivationsLeft 887 float 0;
#X coords 0 1 886 0 250 70 1 0 0;
#X restore 365 150 graph;
#N canvas 0 23 450 278 (subpatch) 0;
#X array ActivationsRight 887 float 0;
#X coords 0 1 886 0 250 70 1 0 0;
#X restore 365 237 graph;
#X obj 113 -338 s draw;
#X obj 113 -277 r draw;
#X obj 157 -362 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000;
#X obj 193 -23 array size;
#X obj 113 1 array get;
#X obj 113 -84 t b b b, f 12;
#X obj 113 -107 r draw;
#X msg 194 -58 symbol help.nmf.bases.2-1;
#X obj 193 0 array size BasesRight;
#X obj 113 24 array set BasesRight;
#X obj 483 -183 array size;
#X obj 403 -159 array get;
#X obj 403 -244 t b b b, f 12;
#X obj 403 -267 r draw;
#X obj 483 -13 array size;
#X obj 403 11 array get;
#X obj 403 -74 t b b b, f 12;
#X obj 403 -97 r draw;
#X msg 484 -218 symbol help.nmf.activations.2-0;
#X msg 484 -48 symbol help.nmf.activations.2-1;
#X obj 483 -160 array size ActivationsLeft;
#X obj 403 -136 array set ActivationsLeft;
#X obj 483 10 array size ActivationsRight;
#X obj 403 34 array set ActivationsRight;
#X connect 1 0 4 0;
#X connect 2 0 5 0;
#X connect 6 0 11 0;
#X connect 7 0 2 0;
#X connect 7 1 1 0;
#X connect 7 2 8 0;
#X connect 8 0 1 1;
#X connect 8 0 2 2;
#X connect 12 0 7 0;
#X connect 13 0 11 0;
#X connect 14 0 19 0;
#X connect 15 0 20 0;
#X connect 16 0 15 0;
#X connect 16 1 14 0;
#X connect 16 2 18 0;
#X connect 17 0 16 0;
#X connect 18 0 14 1;
#X connect 18 0 15 2;
#X connect 21 0 31 0;
#X connect 22 0 32 0;
#X connect 23 0 22 0;
#X connect 23 1 21 0;
#X connect 23 2 29 0;
#X connect 24 0 23 0;
#X connect 25 0 33 0;
#X connect 26 0 34 0;
#X connect 27 0 26 0;
#X connect 27 1 25 0;
#X connect 27 2 30 0;
#X connect 28 0 27 0;
#X connect 29 0 21 1;
#X connect 29 0 22 2;
#X connect 30 0 25 1;
#X connect 30 0 26 2;
#X coords 0 -1 1 1 520 210 1 100 100;
#X restore 15 484 pd visualisation;
#X text 12 112 In the previous tab you can see how fluid.bufnmf~ can be used to decompose a sound into some components. We can also spy on the information that the object uses to perform this decomposition: the bases and activations. In either case we can extract these two things from the process by specifing the relevant attributes in the object., f 94;
#X text 14 72 Bases and activations: the data under the hood that powers the NMF process, f 75;
#X obj 15 287 soundfiler;
#X obj 446 241 array define help.nmf.src.2;
#X obj 15 389 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000;
#X obj 15 409 fluid.bufnmf -source help.nmf.src.2 -bases help.nmf.bases.2 -activations help.nmf.activations.2 -components 2;
#X obj 15 449 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000;
#X obj 349 264 clone fluid.multiarray 2 help.nmf.bases.2;
#X obj 308 287 clone fluid.multiarray 2 help.nmf.activations.2;
#X text 37 449 bang when done;
#X obj 35 388 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X text 56 387 send a bang to start processing;
#X msg 15 265 read -resize \$1 help.nmf.src.2;
#X obj 16 199 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X obj 15 218 fluid.demoaudiofiles;
#X text 17 199 1) Pick a source;
#X text 36 387 2);
#X text 17 702 You can think of bases like filters for each component., f 27;
#X text 276 700 The activations are like "how active is this component" at a given point in time., f 41;
#X connect 6 0 7 0;
#X connect 7 0 8 0;
#X connect 8 0 1 0;
#X connect 14 0 4 0;
#X connect 16 0 14 0;
#X restore 461 690 pd bases_and_activation1;
#N canvas 179 99 694 820 bases_and_activation2 0;
#X obj 15 13 cnv 15 660 42 empty empty fluid.bufnmf 1 22 0 36 #4ba3fb #ffffff 0;
#X text 14 72 Using bases and activations;
#X obj 17 532 fluid.out~ bufnmfhelp;
#X obj 87 529 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#N canvas 1622 -867 388 477 srcselect 0;
#X obj 60 71 inlet~;
#X obj 140 71 inlet~;
#X obj 221 71 inlet;
#X obj 62 371 +~;
#X obj 62 395 outlet~;
#X obj 221 172 == 0;
#X obj 221 150 tgl 15 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 221 198 tgl 15 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X msg 219 266 \$1 10;
#X obj 219 292 line~;
#X obj 273 71 loadbang;
#X msg 273 96 0;
#X msg 78 266 \$1 10;
#X obj 78 294 line~;
#X obj 60 330 *~;
#X obj 140 330 *~;
#X connect 0 0 14 0;
#X connect 1 0 15 0;
#X connect 2 0 6 0;
#X connect 3 0 4 0;
#X connect 5 0 7 0;
#X connect 6 0 5 0;
#X connect 6 0 12 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 9 0 15 1;
#X connect 10 0 11 0;
#X connect 11 0 6 0;
#X connect 12 0 13 0;
#X connect 13 0 14 1;
#X connect 14 0 3 0;
#X connect 15 0 3 1;
#X restore 17 388 pd srcselect;
#X f 21;
#X obj 142 140 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X obj 161 183 vradio 15 1 0 2 empty empty empty 0 -8 0 10 #fcfcfc #000000 #000000 0;
#X text 144 139 2) select an activation to listen to, f 23;
#X text 179 179 activation 1;
#X text 179 199 activation 2;
#X obj 17 436 lop~ 80;
#X obj 17 484 *~;
#N canvas 897 -937 461 267 pink 0;
#X obj 24 135 outlet~;
#X obj 24 43 noise~;
#X obj 24 69 fexpr~ $x1[0] * 0.049922 + $x1[-1] * -0.0959935 + $x1[-2] * 0.0506127 + $x1[-3] * -0.00440879 + $y1[-1] * 2.49496 + $y1[-2] * -2.01727 + $y1[-3] * 0.522189;
#X text 5 163 ref: https://ccrma.stanford.edu/~jos/sasp/Example_Synthesis_1_F_Noise.html with the help of https://uk.mathworks.com/help/matlab/ref/filter.html#buagwwg-2, f 69;
#X text 8 5 pink-noise-approximator taken from the literature. More accurate than ~pink but more expensive too!, f 65;
#X obj 24 112 *~ 5;
#X connect 1 0 2 0;
#X connect 2 0 5 0;
#X connect 5 0 0 0;
#X restore 80 436 pd pink;
#X obj 17 244 tabread4~ help.nmf.activations.2-0, f 26;
#X obj 37 284 tabread4~ help.nmf.activations.2-1, f 28;
#X obj 17 175 phasor~ 0.1;
#X obj 17 203 *~ 889;
#X obj 333 611 fluid.nmffilter~ 2 -bases help.nmf.bases.2, f 30;
#X obj 333 772 fluid.out~ bufnmfhelp;
#X obj 403 769 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#N canvas 1622 -867 388 477 srcselect 0;
#X obj 60 71 inlet~;
#X obj 140 71 inlet~;
#X obj 221 71 inlet;
#X obj 62 371 +~;
#X obj 62 395 outlet~;
#X obj 221 172 == 0;
#X obj 221 150 tgl 15 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 221 198 tgl 15 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X msg 219 266 \$1 10;
#X obj 219 292 line~;
#X obj 273 71 loadbang;
#X msg 273 96 0;
#X msg 78 266 \$1 10;
#X obj 78 294 line~;
#X obj 60 330 *~;
#X obj 140 330 *~;
#X connect 0 0 14 0;
#X connect 1 0 15 0;
#X connect 2 0 6 0;
#X connect 3 0 4 0;
#X connect 5 0 7 0;
#X connect 6 0 5 0;
#X connect 6 0 12 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 9 0 15 1;
#X connect 10 0 11 0;
#X connect 11 0 6 0;
#X connect 12 0 13 0;
#X connect 13 0 14 1;
#X connect 14 0 3 0;
#X connect 15 0 3 1;
#X restore 333 728 pd srcselect;
#X f 30;
#X obj 499 663 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X obj 540 685 vradio 15 1 0 2 empty empty empty 0 -8 0 10 #fcfcfc #000000 #000000 0;
#X text 558 682 bases 1;
#X text 558 699 bases 2;
#X text 501 661 4) select a base, f 23;
#X obj 313 196 bng 15 250 50 0 empty empty empty 17 7 0 10 #c6ffc7 #000000 #000000;
#X obj 313 215 tabplay~ help.nmf.src.2;
#X text 88 528 1) turn this sound on;
#X text 404 768 3) turn this sound on;
#X obj 372 139 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X text 374 138 5) play a source through the nmffilter with the selected base, f 34;
#X obj 336 320 readsf~;
#X msg 336 263 open ./media/Tremblay-AaS-AcousticStrums-M.wav \, 1, f 23;
#X obj 358 424 readsf~;
#X obj 336 244 bng 15 250 50 0 empty empty empty 17 7 0 10 #c6ffc7 #000000 #000000;
#X obj 358 349 bng 15 250 50 0 empty empty empty 17 7 0 10 #c6ffc7 #000000 #000000;
#X text 386 479 In a similar fashion we might also use the bases from NMF as filters for any other kind of sound. We could do this manually with rfft~ or we could use the fluid.nmffilter~ object here to simplify things., f 38;
#X msg 358 367 open ./media/Olencki-TenTromboneLongTones-M.wav \, 1, f 24;
#X connect 4 0 10 0;
#X connect 6 0 4 2;
#X connect 10 0 11 0;
#X connect 11 0 2 1;
#X connect 11 0 2 0;
#X connect 12 0 11 1;
#X connect 13 0 4 0;
#X connect 14 0 4 1;
#X connect 15 0 16 0;
#X connect 16 0 13 0;
#X connect 16 0 14 0;
#X connect 17 0 20 0;
#X connect 17 1 20 1;
#X connect 20 0 18 0;
#X connect 20 0 18 1;
#X connect 22 0 20 2;
#X connect 26 0 27 0;
#X connect 27 0 17 0;
#X connect 32 0 17 0;
#X connect 33 0 32 0;
#X connect 34 0 17 0;
#X connect 35 0 33 0;
#X connect 36 0 38 0;
#X connect 38 0 34 0;
#X restore 461 712 pd bases_and_activation2;
#N canvas 229 25 695 790 vocoder 0;
#X obj 15 13 cnv 15 660 42 empty empty fluid.bufnmf 1 22 0 36 #4ba3fb #ffffff 0;
#X text 14 72 Using bases and activations to create a vododer;
#X text 14 102 You might find it useful to think of the NMF algorithm as a bit like a vododer. This abstraction below demonstrates how you could use the bases and activations to reconstruct a sound in realtime \, based on what the algorithm has learned., f 89;
#N canvas 1115 -815 874 653 fluid.bufnmf.noiseplay.fft 0;
#X obj 175 46 inlet~;
#X obj 74 117 *~;
#X obj 74 158 rfft~;
#X obj 74 222 rifft~;
#X obj 35 355 *~;
#X obj 35 413 outlet~;
#X obj 34 46 tabreceive~ fluid.bufnmf.hann, f 19;
#X obj 113 189 *~;
#X obj 74 189 *~;
#X obj 246 46 inlet;
#X obj 492 197 bang~;
#X obj 16 10 block~ 1024 4;
#X obj 492 258 t f f, f 7;
#X obj 596 197 - 1;
#X obj 469 46 inlet;
#X obj 35 386 *~;
#X obj 469 71 t a b a, f 17;
#X obj 585 104 list split 1;
#N canvas 556 77 450 468 make.scaled.hann.window 0;
#X obj 107 94 t f b;
#X msg 107 71 1024;
#X obj 107 136 until;
#X msg 107 157 1;
#X obj 107 178 +;
#X msg 148 156 -1;
#X obj 107 348 array define fluid.bufnmf.hann 1024;
#X obj 107 197 t f f f;
#X obj 106 324 tabwrite fluid.bufnmf.hann;
#X obj 107 218 / 1024;
#X obj 107 260 sin;
#X obj 107 281 *;
#X obj 234 134 expr 4*atan(1);
#X obj 107 239 * 3.1;
#X obj 107 47 t b b;
#X obj 107 302 * 0.0255155;
#X obj 107 26 loadbang;
#X obj 181 26 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000;
#X connect 0 0 2 0;
#X connect 0 1 5 0;
#X connect 1 0 0 0;
#X connect 2 0 3 0;
#X connect 3 0 4 0;
#X connect 4 0 7 0;
#X connect 5 0 4 1;
#X connect 7 0 9 0;
#X connect 7 1 4 1;
#X connect 7 2 8 1;
#X connect 9 0 13 0;
#X connect 10 0 11 0;
#X connect 10 0 11 1;
#X connect 11 0 15 0;
#X connect 12 0 13 1;
#X connect 13 0 10 0;
#X connect 14 0 1 0;
#X connect 14 1 12 0;
#X connect 15 0 8 0;
#X connect 16 0 14 0;
#X connect 17 0 14 0;
#X restore 117 10 pd make.scaled.hann.window;
#X obj 246 71 tabreceive~ help.nmf.bases.2-0;
#X obj 527 137 array size help.nmf.activations.2-0, f 25;
#X obj 472 287 tabread help.nmf.activations.2-0;
#X obj 493 223 expr if($f3 < $f2 \, $f3 + 0.5 \, 0);
#X connect 0 0 1 1;
#X connect 1 0 2 0;
#X connect 2 0 8 0;
#X connect 2 1 7 0;
#X connect 3 0 4 1;
#X connect 4 0 15 0;
#X connect 6 0 1 0;
#X connect 6 0 4 0;
#X connect 7 0 3 1;
#X connect 8 0 3 0;
#X connect 9 0 19 0;
#X connect 10 0 22 0;
#X connect 12 0 21 0;
#X connect 12 1 22 2;
#X connect 13 0 22 1;
#X connect 14 0 16 0;
#X connect 15 0 5 0;
#X connect 16 0 21 0;
#X connect 16 1 20 0;
#X connect 16 2 17 0;
#X connect 17 1 20 1;
#X connect 19 0 7 1;
#X connect 19 0 8 1;
#X connect 20 0 13 0;
#X connect 21 0 15 1;
#X connect 22 0 12 0;
#X restore 47 433 pd fluid.bufnmf.noiseplay.fft;
#X obj 46 301 noise~;
#X obj 46 322 *~ 4;
#X text 73 452 combine the timing profile from one component with the spectral profile of another;
#X obj 147 198 loadbang;
#X msg 147 222 0;
#X obj 247 273 vradio 15 1 0 2 empty empty empty 0 -8 0 10 #fcfcfc #000000 #000000 0;
#X text 265 269 activation 1;
#X text 265 289 activation 2;
#X obj 147 273 vradio 15 1 0 2 empty empty empty 0 -8 0 10 #fcfcfc #000000 #000000 0;
#X text 165 269 base 1;
#X text 165 289 base 2;
#X obj 48 747 fluid.out~ bufnmfhelp;
#X obj 118 752 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X msg 247 383 set help.nmf.activations.2-\$1, f 25;
#X msg 147 342 set help.nmf.bases.2-\$1, f 19;
#N canvas 1149 -1008 955 628 visualisation 0;
#N canvas 0 23 450 278 (subpatch) 0;
#X array Bases 100 float 0;
#X coords 0 1 99 0 250 70 1 0 0;
#X restore 105 150 graph;
#X obj 193 -3 array size;
#X obj 113 21 array get;
#X obj 113 -172 inlet;
#N canvas 0 23 450 278 (subpatch) 0;
#X array Activations 100 float 0;
#X coords 0 1 99 0 250 70 1 0 0;
#X restore 105 237 graph;
#X obj 483 -3 array size;
#X obj 403 21 array get;
#X obj 113 -74 t b b f, f 12;
#X obj 113 44 array set Bases;
#X obj 193 21 array size Bases;
#X msg 194 -38 symbol help.nmf.bases.2-\$1;
#X msg 484 -38 symbol help.nmf.activations.2-\$1;
#X obj 483 21 array size Activations;
#X obj 403 44 array set Activations;
#X obj 403 -170 inlet;
#X obj 403 -74 t b b f, f 12;
#X connect 1 0 9 0;
#X connect 2 0 8 0;
#X connect 3 0 7 0;
#X connect 5 0 12 0;
#X connect 6 0 13 0;
#X connect 7 0 2 0;
#X connect 7 1 1 0;
#X connect 7 2 10 0;
#X connect 10 0 1 1;
#X connect 10 0 2 2;
#X connect 11 0 5 1;
#X connect 11 0 6 2;
#X connect 14 0 15 0;
#X connect 15 0 6 0;
#X connect 15 1 5 0;
#X connect 15 2 11 0;
#X coords 0 -1 1 1 260 210 1 100 100;
#X restore 338 530 pd visualisation;
#X obj 206 235 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X text 119 751 1) turn sound on;
#X text 207 234 2) select a combination of base and activation;
#X connect 3 0 15 0;
#X connect 3 0 15 1;
#X connect 4 0 5 0;
#X connect 5 0 3 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 8 0 12 0;
#X connect 9 0 17 0;
#X connect 9 0 19 1;
#X connect 12 0 18 0;
#X connect 12 0 19 0;
#X connect 17 0 3 2;
#X connect 18 0 3 1;
#X restore 461 734 pd vocoder;
#N canvas 357 162 691 770 multichannel 0;
#X text 16 113 fluid.bufnmf will process each channel independently;
#X obj 21 355 soundfiler;
#X obj 21 376 t b;
#X obj 25 716 clone fluid.multiarray 2 bufnmf_bells;
#X obj 25 740 clone fluid.multiarray 24 bufnmf_bells_resynth;
#X obj 21 438 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000;
#X msg 21 334 read -resize media/Tremblay-CF-ChurchBells.wav bufnmf_bells-0 bufnmf_bells-1, f 80;
#X text 22 615 in this case we've decomposed in to enough components to latch onto partials in the bell sound \, but you can hear that the left and right haven't converged to the *same* partials. See the 'technical details' tab for an explanation., f 89;
#X floatatom 222 472 5 0 11 0 - - - 0;
#X obj 222 519 tabplay~;
#X msg 222 496 set bufnmf_bells_resynth-\$1 \, bang;
#X obj 286 561 tabplay~;
#X msg 286 540 set bufnmf_bells_resynth-\$1 \, bang;
#X obj 285 520 + 12;
#X obj 15 13 cnv 15 660 42 empty empty fluid.bufnmf 1 22 0 36 #4ba3fb #ffffff 0;
#X text 15 64 Processing multichannel buffers with fluid.bufnmf~;
#X text 14 157 The output channels (in resynth \, bases and activations buffer~s) will be grouped by component. For example \, with a stereo input and 2 components:, f 73;
#X text 14 205 channel 1: channel 1 \, component 1;
#X text 14 221 channel 2: channel 1 \, component 2;
#X text 14 237 channel 3: channel 2 \, component 1;
#X text 14 253 channel 4: channel 2 \, component 2;
#X obj 222 583 fluid.out~;
#X floatatom 465 433 8 0 0 0 - - - 0;
#X obj 21 396 fluid.bufnmf -source bufnmf_bells -resynth bufnmf_bells_resynth -resynthmode 1 -components 12 -blocking 0, f 64;
#X obj 23 311 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X text 24 310 1);
#X text 44 310 load a stereo file and decompose it;
#X obj 294 590 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X obj 267 473 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X text 266 472 3) select components to hear;
#X text 293 589 2) audio on;
#X connect 1 0 2 0;
#X connect 2 0 23 0;
#X connect 6 0 1 0;
#X connect 8 0 10 0;
#X connect 8 0 13 0;
#X connect 9 0 21 0;
#X connect 10 0 9 0;
#X connect 11 0 21 1;
#X connect 12 0 11 0;
#X connect 13 0 12 0;
#X connect 23 0 5 0;
#X connect 23 3 22 0;
#X restore 461 800 pd multichannel;
#N canvas 288 25 696 790 updating_bases 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X array help.nmf.src.5 88200 float 2;
#X coords 0 1 88200 -1 455 50 1 0 0;
#X restore 16 261 graph;
#N canvas 121 159 450 278 (subpatch) 0;
#X array help.nmf.bases.5-0 513 float 0;
#X coords 0 1 512 0 240 70 1 0 0;
#X restore 18 409 graph;
#N canvas 0 22 450 278 (subpatch) 0;
#X array help.nmf.bases.5-1 513 float 0;
#X coords 0 1 512 0 240 70 1 0 0;
#X restore 17 496 graph;
#X obj 18 343 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000;
#N canvas 731 210 833 684 make_2_tones 0;
#X msg 38 172 44100;
#X obj 57 220 until;
#X msg 125 241 -1;
#X msg 57 241 1;
#X obj 57 262 +;
#X obj 57 285 t f f f f f, f 75;
#X obj 38 402 fluid.bufcompose;
#X obj 38 146 loadbang;
#X obj 39 82 array define lowsine2 44100;
#X obj 39 107 array define hisine2 44100;
#X obj 57 329 tabwrite lowsine2;
#X obj 364 331 tabwrite hisine2;
#X msg 38 365 reset \, destgain 1 \, destination help.nmf.src.5 \, source lowsine2 \, bang \, source hisine2 \, deststartframe 44100 \, bang;
#X msg 172 186 \; help.nmf.src.5 const;
#X obj 38 193 t b f b b;
#X msg 38 427 \; help.nmf.src.5 xticks 0 0 0;
#X obj 57 308 expr sin($f1 / 22050 * 3.14159 * 50) * 0.5;
#X obj 364 310 expr sin($f1 / 22050 * 3.14159 * 5000) * 0.5;
#X connect 0 0 14 0;
#X connect 1 0 3 0;
#X connect 2 0 4 1;
#X connect 3 0 4 0;
#X connect 4 0 5 0;
#X connect 5 0 16 0;
#X connect 5 1 10 1;
#X connect 5 2 17 0;
#X connect 5 3 11 1;
#X connect 5 4 4 1;
#X connect 6 0 15 0;
#X connect 7 0 0 0;
#X connect 12 0 6 0;
#X connect 14 0 12 0;
#X connect 14 1 1 0;
#X connect 14 2 2 0;
#X connect 14 3 13 0;
#X connect 16 0 10 0;
#X connect 17 0 11 0;
#X restore 13 203 pd make_2_tones;
#X obj 15 13 cnv 15 660 42 empty empty fluid.bufnmf 1 22 0 36 #4ba3fb #ffffff 0;
#X text 13 73 Using the basesmode or actmode attributes in update \, we can set NMF's starting conditions \, but let it improve to 'find' particular spectral components, f 78;
#X obj 21 604 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000;
#X obj 21 630 fluid.bufnmf -source help.nmf.src.5 -bases help.nmf.bases.5 -components 2 -iterations 25 -basesmode 1 -resynthmode 1 -resynth help.nmf.resynth.5, f 35;
#N canvas 2023 -1000 409 408 initialise_some_bases 0;
#X obj 27 12 inlet;
#X obj 27 94 until;
#X obj 27 68 t f b, f 10;
#X obj 27 169 +;
#X obj 27 200 t f f f f f, f 34;
#X msg 27 43 513;
#X obj 27 251 < 50;
#X obj 166 251 >= 50;
#X msg 27 124 1;
#X msg 94 124 -1;
#X obj 28 299 tabwrite help.nmf.bases.5-0, f 18;
#X obj 166 299 tabwrite help.nmf.bases.5-1, f 18;
#X connect 0 0 5 0;
#X connect 1 0 8 0;
#X connect 2 0 1 0;
#X connect 2 1 9 0;
#X connect 3 0 4 0;
#X connect 4 0 6 0;
#X connect 4 1 10 1;
#X connect 4 2 7 0;
#X connect 4 3 11 1;
#X connect 4 4 3 1;
#X connect 5 0 2 0;
#X connect 6 0 10 0;
#X connect 7 0 11 0;
#X connect 8 0 3 0;
#X connect 9 0 3 1;
#X restore 18 363 pd initialise_some_bases;
#X obj 503 127 clone fluid.multiarray 2 help.nmf.resynth.5, f 24;
#X obj 21 713 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000;
#X obj 490 333 fluid.out~ bufnmfhelp;
#X obj 490 280 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000;
#X obj 490 261 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X obj 133 203 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X text 134 202 1) compose a buffer os two sine waves \, one second each in sequence, f 40;
#X obj 43 343 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X text 44 342 4) create some very crude initialising bases;
#X obj 43 603 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X text 278 629 Every time you bang the bases are incrementally updated as the algorithm "learns" about the decomposition. Try playing back the result on the right at each stage to see how it progresses., f 34;
#X text 44 602 5) incrementally update the initialised bases;
#X obj 559 338 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X obj 490 304 tabplay~ help.nmf.src.5;
#X obj 460 533 fluid.out~ bufnmfhelp;
#X obj 460 420 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000;
#X obj 460 401 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X obj 460 444 tabplay~ help.nmf.resynth.5-0, f 21;
#X obj 489 480 tabplay~ help.nmf.resynth.5-1, f 21;
#X text 307 525 Left is component 1 Right is component 2, f 21;
#X text 560 337 2) audio on;
#X text 491 260 3) listen to source;
#X obj 530 540 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X text 461 400 7) listen to decomposition;
#X text 531 539 6) audio on;
#X connect 3 0 9 0;
#X connect 7 0 8 0;
#X connect 8 0 11 0;
#X connect 13 0 23 0;
#X connect 23 0 12 0;
#X connect 23 0 12 1;
#X connect 25 0 27 0;
#X connect 25 0 28 0;
#X connect 27 0 24 0;
#X connect 28 0 24 1;
#X restore 461 778 pd updating_bases;
#X obj 15 220 soundfiler;
#X obj 15 176 loadbang;
#X obj 15 74 cnv 15 380 17 empty empty Buffer-Based\ Non-Negative\ Matrix\ Factorisation 4 8 0 13 #e0e0e0 #404040 0;
#X obj 17 744 fluid.out~ bufnmfhelp;
#X obj 15 13 cnv 15 660 42 empty empty fluid.bufnmf 1 22 0 36 #4ba3fb #ffffff 0;
#X obj 479 60 fluid.referencelauncher fluid.bufnmf.html reference/bufnmf/;
#X obj 38 320 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X obj 15 88 cnv 15 380 17 empty empty on\ Spectral\ Frames 4 8 0 13 #e0e0e0 #404040 0;
#X obj 17 392 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000;
#X obj 17 320 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000;
#X text 39 319 1);
#X text 59 319 send a bang to start processing;
#X text 189 568 Each component of the decomposition will be in a separate channel of the destination buffer~., f 45;
#X text 15 119 Decomposes the spectrum of a sound into a number of components using Non-Negative Matrix Factorisation (NMF), f 67;
#X msg 15 198 read -resize media/Nicol-LoopE-M.wav help.nmf.src.1;
#X obj 15 249 array define help.nmf.src.1;
#X obj 17 352 fluid.bufnmf -source help.nmf.src.1 -resynth help.nmf.resynth.1 -components 2 -resynthmode 1;
#X obj 17 573 tabplay~ help.nmf.resynth.1-0, f 21;
#X text 427 454 If you decompose the same sound multiple times you will get roughly the same components but possibly in a different order. This is beacuse the NMF algorithm starts from a random state., f 35;
#X obj 17 499 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000;
#X obj 134 622 tabplay~ help.nmf.resynth.1-1, f 21;
#X obj 87 749 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X obj 17 480 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#N canvas 982 260 388 477 srcselect 0;
#X obj 60 71 inlet~;
#X obj 140 71 inlet~;
#X obj 221 71 inlet;
#X obj 62 371 +~;
#X obj 62 395 outlet~;
#X msg 219 266 \$1 10;
#X obj 219 292 line~;
#X obj 273 71 loadbang;
#X msg 273 96 0;
#X msg 78 266 \$1 10;
#X obj 78 294 line~;
#X obj 60 330 *~;
#X obj 140 330 *~;
#X obj 221 127 sel 2;
#X msg 221 151 1;
#X obj 253 192 == 0;
#X obj 253 216 == 0;
#X connect 0 0 11 0;
#X connect 1 0 12 0;
#X connect 2 0 13 0;
#X connect 3 0 4 0;
#X connect 5 0 6 0;
#X connect 6 0 12 1;
#X connect 7 0 8 0;
#X connect 9 0 10 0;
#X connect 10 0 11 1;
#X connect 11 0 3 0;
#X connect 12 0 3 1;
#X connect 13 0 14 0;
#X connect 13 1 15 0;
#X connect 14 0 5 0;
#X connect 14 0 9 0;
#X connect 15 0 9 0;
#X connect 15 0 16 0;
#X connect 16 0 5 0;
#X restore 17 668 pd srcselect;
#X f 34;
#X obj 234 430 cnv 15 15 15 empty empty empty 20 12 0 14 #c6ffc7 #404040 0;
#X text 18 479 4) play the component;
#X text 271 448 component 1;
#X text 271 466 component 2;
#X obj 253 452 vradio 15 1 0 3 empty empty empty 0 -8 0 10 #fcfcfc #000000 #000000 0;
#X obj 369 265 clone fluid.multiarray 2 help.nmf.resynth.1;
#X obj 461 823 note_on_multithreading;
#X text 271 483 both together;
#X obj 461 844 note_on_automatic_multiarrays;
#X text 235 429 2) select a component to listen to;
#X text 88 748 3) turn sound on;
#X connect 8 0 21 0;
#X connect 16 0 23 0;
#X connect 21 0 7 0;
#X connect 23 0 15 0;
#X connect 24 0 30 0;
#X connect 26 0 27 0;
#X connect 26 0 24 0;
#X connect 27 0 30 1;
#X connect 30 0 10 0;
#X connect 30 0 10 1;
#X connect 35 0 30 2;
